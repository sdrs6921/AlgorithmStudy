# Minimum Spanning Tree - 다리 만들기2

<img width="1182" alt="스크린샷 2020-11-02 오후 5 24 31" src="https://user-images.githubusercontent.com/42570260/97845817-6e3c1880-1d30-11eb-8ede-ff37ae617f70.png">
<img width="1182" alt="스크린샷 2020-11-02 오후 5 24 49" src="https://user-images.githubusercontent.com/42570260/97845831-71cf9f80-1d30-11eb-8d95-6eac89a1c51f.png">
<img width="1182" alt="스크린샷 2020-11-02 오후 5 25 16" src="https://user-images.githubusercontent.com/42570260/97845835-73996300-1d30-11eb-9fc5-e8d22fbbc4f9.png">
</br></br>

## 문제 풀이
- 지도의 가로 크기, 세로 크기, 지도의 정보가 주어지는데, 만약 땅이라면 1, 땅이 아니라면 0의 지도 정보가 주어진다.
- 모든 섬을 연결하는 다리의 길이의 최소값을 출력
- 제한 조건 : 다리의 길이가 무조건 2이상일 경우에만 다리를 지을 수 있으며, 만약 다리를 지을 수 없는 경우 -1을 출력

### 1. 섬의 위치를 구분
#### Count 변수와 BFS 알고리즘을 통해 지도 내의 섬의 개수와 Count 변수로 Map을 할당하여 섬을 (1, 2, 3)으로 구분

### 2. 섬 간의 최소 거리
#### 다시 반복문으로 섬의 개수만큼 BFS 알고리즘을 사용하여 섬 간의 최소 거리를 구한다.
#### dist 배열을 사용하여 가로와 세로 각각을 탐색하여 섬 간 최소 직선 거리를 가질 수 있는 경우를 탐색한다.
#### 2 이상의 거리를 가진 섬을 발견한다면 Edge List에 추가한다.

### 3. 크루스칼 알고리즘
#### 먼저 간선에 대한 정보를 저장한 List를 정렬
#### Union-Find 알고리즘을 통해 섬 간의 집합 관계를 통해 같은 집합이라면 answer에 거리를 더한다.
#### 모든 섬이 같은 집합일 때까지 크루스칼 알고리즘을 진행하며 다리의 거리를 구한다.
#### 마지막으로 다리를 지을 수 없는 경우를 탐색하기 위해 Union-Find 에서 사용한 Parent 배열을 탐색한다.
#### Parent배열에서 하나의 요소라도 1이 아닌경우 -1을 출력 (Union-Find 에서 Union할 경우 더 작은 수로 parent배열을 초기화 하기 때문 따라서 가장 최 정점의 노드는 1이 됨)
